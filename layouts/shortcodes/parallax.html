{{/*
Vekllei Flexible Parallax Shortcode - Optimized Loading
*/}}

{{- $layers := 8 -}}
{{- $max_transform := 800 -}}
{{- $height := "80vh" -}}
{{- $image_path := "/images/mastheads/parallax/characters/" -}}
{{- $bg_light := "#5AC2E7" -}}
{{- $bg_dark := "#1a1b28" -}}

{{- if .Get 0 }}{{ $layers = .Get 0 | int }}{{ end -}}
{{- if .Get 1 }}{{ $max_transform = .Get 1 | int }}{{ end -}}
{{- if .Get 2 }}{{ $height = .Get 2 }}{{ end -}}
{{- if .Get 3 }}{{ $image_path = .Get 3 }}{{ end -}}
{{- if .Get 4 }}{{ $bg_light = .Get 4 }}{{ end -}}
{{- if .Get 5 }}{{ $bg_dark = .Get 5 }}{{ end -}}

{{- $unique_id := printf "parallax-%d" (now.Unix) -}}

{{/* Calculate transform increment */}}
{{- $increment := 0 -}}
{{- if gt $layers 1 -}}
    {{- $increment = div $max_transform (sub $layers 1) -}}
{{- end -}}

<style>
.{{ $unique_id }}-container {
    position: relative;
    width: 100vw;
    height: {{ $height }};
    overflow: hidden;
    background: {{ $bg_light }};
    margin-left: calc((100% - 100vw) / 2);
    contain: layout style paint;
}

[data-theme="dark"] .{{ $unique_id }}-container {
    background: {{ $bg_dark }};
}

.{{ $unique_id }}-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-repeat: no-repeat;
    background-position: center center;
    background-size: cover;
    will-change: transform;
    transform: translate3d(0, 0, 0);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease-in;
}

.{{ $unique_id }}-layer.loaded {
    opacity: 1;
}

{{- range $i := seq 1 $layers -}}
{{- $layer_num := $i -}}
{{- $z_index := sub (add $layers 1) $i -}}

.{{ $unique_id }}-layer-{{ $layer_num }} {
    z-index: {{ $z_index }};
}
{{- end }}

.{{ $unique_id }}-content {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: {{ add $layers 1000 }};
    color: white;
    text-align: center;
    padding: 2rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
    pointer-events: none;
}

@media (prefers-reduced-motion: reduce) {
    .{{ $unique_id }}-layer {
        transform: none !important;
    }
}
</style>

<div class="{{ $unique_id }}-container" data-parallax-container="{{ $unique_id }}">
    {{- range $i := seq $layers 1 -}}
    {{- $layer_num := $i -}}
    {{- $transform_value := 0 -}}
    {{- if gt $i 1 -}}
        {{- $transform_value = mul $increment (sub $i 1) -}}
    {{- end -}}
    <div class="{{ $unique_id }}-layer {{ $unique_id }}-layer-{{ $layer_num }}" 
         data-speed="{{ $transform_value }}"
         data-src="{{ $image_path }}{{ $layer_num }}.png"
         data-priority="{{ $layer_num }}"></div>
    {{- end }}

    {{- if .Inner }}
    <div class="{{ $unique_id }}-content">
        {{ .Inner | markdownify }}
    </div>
    {{- end }}
</div>

<script>
(function() {
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        return;
    }

    const container = document.querySelector('[data-parallax-container="{{ $unique_id }}"]');
    if (!container) return;

    const layers = container.querySelectorAll('.{{ $unique_id }}-layer');
    
    let bounds = null;
    let isVisible = false;
    let lastScrollY = -1;
    let animationFrame = null;
    let imagesLoaded = 0;
    let animationActive = false;

    const layerData = Array.from(layers).map(layer => ({
        element: layer,
        speed: parseFloat(layer.dataset.speed) || 0,
        src: layer.dataset.src,
        priority: parseInt(layer.dataset.priority)
    }));

    // Load images progressively with delays to reduce CPU spike
    function loadImages() {
        // Sort by priority (front layers first)
        const sortedLayers = [...layerData].sort((a, b) => a.priority - b.priority);
        
        sortedLayers.forEach((layer, index) => {
            // Stagger image loads by 100ms each
            setTimeout(() => {
                const img = new Image();
                img.decoding = 'async'; // Use async decoding
                
                img.onload = () => {
                    layer.element.style.backgroundImage = `url('${layer.src}')`;
                    // Use a small delay before showing to ensure it's rendered
                    requestAnimationFrame(() => {
                        layer.element.classList.add('loaded');
                    });
                    
                    imagesLoaded++;
                    
                    // Start animation once first 3 layers are loaded
                    if (imagesLoaded >= 3 && !animationActive && isVisible) {
                        animationActive = true;
                        onScroll();
                    }
                };
                
                img.onerror = () => {
                    console.warn('Failed to load parallax layer:', layer.src);
                };
                
                img.src = layer.src;
            }, index * 100); // 100ms between each image
        });
    }

    function updateBounds() {
        const rect = container.getBoundingClientRect();
        bounds = {
            top: rect.top + window.scrollY,
            height: rect.height,
            windowHeight: window.innerHeight
        };
    }

    function updateParallax() {
        if (!isVisible || !bounds || !animationActive) {
            animationFrame = null;
            return;
        }

        const scrollY = window.scrollY;
        
        if (scrollY === lastScrollY) {
            animationFrame = null;
            return;
        }
        
        lastScrollY = scrollY;

        const containerCenter = bounds.top + bounds.height / 2;
        const screenCenter = scrollY + bounds.windowHeight / 2;
        const progress = Math.max(-1, Math.min(1, 
            (screenCenter - containerCenter) / ((bounds.windowHeight + bounds.height) / 2)
        ));

        layerData.forEach(({ element, speed }) => {
            if (speed === 0) return;
            element.style.transform = `translate3d(0, ${(progress * speed).toFixed(2)}px, 0)`;
        });

        animationFrame = null;
    }

    function onScroll() {
        if (!animationFrame && animationActive) {
            animationFrame = requestAnimationFrame(updateParallax);
        }
    }

    const observer = new IntersectionObserver((entries) => {
        isVisible = entries[0].isIntersecting;
        
        if (isVisible) {
            updateBounds();
            lastScrollY = -1;
            
            if (animationActive) {
                onScroll();
            }
            
            window.addEventListener('scroll', onScroll, { passive: true });
        } else {
            window.removeEventListener('scroll', onScroll);
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
        }
    }, { 
        rootMargin: '200px',
        threshold: 0
    });

    observer.observe(container);
    
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            updateBounds();
            if (isVisible && animationActive) {
                lastScrollY = -1;
                onScroll();
            }
        }, 200);
    }, { passive: true });

    updateBounds();
    
    // Start loading images
    loadImages();
})();
</script>